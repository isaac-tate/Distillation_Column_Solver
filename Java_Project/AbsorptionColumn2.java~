import java.math.*;

    /* Inputted Data Should Include
     * 
     * Gas inlet flow (gas_in_flow)
     * Gas phase mole fraction (gas_in_mole_frac)
     * Liquid inlet flow (liq_in_flow)
     * Liquid phase mole fraction (liq_in_mole_frac)
     * Recovery (recovery)
     * Inlet temp (temp_in)
     * Packing type (packing)
     * 
     * Outputted Data should include
     * Gas outlet flow (gas_flow_out)
     * Gas phase mole fraction (gas_out_mole_frac)
     * Liquid outlet flow (liq_out_flow)
     * Liquid mole fraction (liq_out_mole_frac)
     * Tower Height (tower_height)
     * 
     */

public class AbsorptionColumn2{
  
  
  
  //Input objects
  Packing packing;
  Fluid fluid;

  //Input values
  double v_1, y_a1, l_2, x_a2, recovery, temp_in;
  
  //System constants
  double vPrime, lPrime, dC, crossArea, x_a1, y_a2;
 
  //Other output values
  double v_2, l_1, z, zl, zv;
  
  //System properties
  int iterations;
  double [] eqdata, xal, yag, xai, yai, dzv, dzl;
  Data [] data;
    
  
  //Constructor
  AbsorptionColumn(Packing packing, Fluid fluid, double[] conditions){
    
    this.packing = packing; //Needs deep copy
    this.fluid = fluid; //Needs deep copy
    
    //Given Inputs
    this.v_1 = conditions[0];
    this.y_a1 = conditions[1];
    this.l_2 = conditions[2];
    this.x_a2 = conditions[3];
    this.recovery = conditions[4];
    this.temp_in = conditions[5];
    
    //Calculating System Constants
    this.crossArea = ((Math.PI*Math.pow((packing.colDiamterHeuristic*packing.nominalSize), 2))/4);
    this.vPrime = (v_1*(1-y_a1)/3600);
    this.lPrime = (l_2*(1-x_a2)/3600);
    this.v_2 = vPrime*3600+(1-recovery)*v_1*y_a1;
    this.y_a2 = y_a1*(1-recovery)*v_1/v_2;
    this.x_a1 = ((vPrime/lPrime)*((y_a1/(1-y_a1))-(y_a2/(1-y_a2))))/(1+((vPrime/lPrime)*((y_a1/(1-y_a1))-(y_a2/(1-y_a2)))));
    this.l_1 = lPrime/(1-x_a1)*3600;
    
    //Calculating System Properties
    this.iterations = conditions[6];
    double delta_x = this.x_a1/this.iterations;//calculate delta x
    this.xal = new double [this.iterations];
    for(int j = 0;j<this.iterations;j++){
      xal[j] = this.x_a1-delta_x*j;//calculate an array of xal values at which each dzv will be calculated
    }
    this.yag = new double [this.iterations];
    this.yag[0] = y_a1;
    for(int k = 0;k<this.iterations-1;k++){
      this.yag[k+1] = ((this.lPrime/this.vPrime)*(((xal[k+1]-delta_x)/(1-(xal[k+1]-delta_x)))-(xal[k]/(1-xal[k])))+(yag[k]/(1-yag[k])))/((this.lPrime/this.vPrime)*(((xal[k+1]-delta_x)/(1-(xal[k+1]-delta_x)))-(xal[k]/(1-xal[k])))+(yag[k]/(1-yag[k]))+1);;//same with yag using eqbm data
    }
    /*this.data = new Data[this.iterations];
    for(int l = 0;l<this.iterations;l++){
      this.data[l] = new Data(xal[l], yag[l], myColumn);//solve for k values etc;//create array to hold L, V, G, MW, k values
    }*///Need to determine data values within the function class for the rootfinding method
    this.xai = new double [iterations];
    this.xai = RootFinding.ridders(Function x);//solve for xai values using the ridders root finding method

  }
  
  
  
}